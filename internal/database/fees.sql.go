// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: fees.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createFeesRecord = `-- name: CreateFeesRecord :one
INSERT INTO fees (fee_structure_id, student_id, paid)
VALUES ($1, $2, $2)
RETURNING fees_id, fee_structure_id, student_id, paid, arrears, status
`

type CreateFeesRecordParams struct {
	FeeStructureID uuid.UUID `json:"fee_structure_id"`
	StudentID      uuid.UUID `json:"student_id"`
}

func (q *Queries) CreateFeesRecord(ctx context.Context, arg CreateFeesRecordParams) (Fee, error) {
	row := q.db.QueryRow(ctx, createFeesRecord, arg.FeeStructureID, arg.StudentID)
	var i Fee
	err := row.Scan(
		&i.FeesID,
		&i.FeeStructureID,
		&i.StudentID,
		&i.Paid,
		&i.Arrears,
		&i.Status,
	)
	return i, err
}

const editFeesRecord = `-- name: EditFeesRecord :exec
UPDATE fees
    SET paid = paid + $2
WHERE fees_id = $1
RETURNING fees_id, fee_structure_id, student_id, paid, arrears, status
`

type EditFeesRecordParams struct {
	FeesID uuid.UUID      `json:"fees_id"`
	Paid   pgtype.Numeric `json:"paid"`
}

func (q *Queries) EditFeesRecord(ctx context.Context, arg EditFeesRecordParams) error {
	_, err := q.db.Exec(ctx, editFeesRecord, arg.FeesID, arg.Paid)
	return err
}

const getStudentFeesRecord = `-- name: GetStudentFeesRecord :one
SELECT
    fees.fees_id,
    students.last_name,
    students.first_name,
    students.middle_name,
    term.name AS AcademicTerm,
    classes.name AS ClassName,
    fee_structure.required AS TuitionAmount,
    fees.paid AS PaidAmount,
    fees.arrears,
    fees.status
FROM fees
INNER JOIN fee_structure 
    ON fees.fee_structure_id = fee_structure.fee_structure_id
INNER JOIN students
    ON fees.student_id = students.student_id
INNER JOIN term
    ON fee_structure.term_id = term.term_id
INNER JOIN classes
    ON fee_structure.class_id = classes.class_id
WHERE students.student_id = $1
`

type GetStudentFeesRecordRow struct {
	FeesID        uuid.UUID      `json:"fees_id"`
	LastName      string         `json:"last_name"`
	FirstName     string         `json:"first_name"`
	MiddleName    pgtype.Text    `json:"middle_name"`
	Academicterm  string         `json:"academicterm"`
	Classname     string         `json:"classname"`
	Tuitionamount pgtype.Numeric `json:"tuitionamount"`
	Paidamount    pgtype.Numeric `json:"paidamount"`
	Arrears       pgtype.Numeric `json:"arrears"`
	Status        string         `json:"status"`
}

func (q *Queries) GetStudentFeesRecord(ctx context.Context, studentID uuid.UUID) (GetStudentFeesRecordRow, error) {
	row := q.db.QueryRow(ctx, getStudentFeesRecord, studentID)
	var i GetStudentFeesRecordRow
	err := row.Scan(
		&i.FeesID,
		&i.LastName,
		&i.FirstName,
		&i.MiddleName,
		&i.Academicterm,
		&i.Classname,
		&i.Tuitionamount,
		&i.Paidamount,
		&i.Arrears,
		&i.Status,
	)
	return i, err
}

const listStudentFeesRecords = `-- name: ListStudentFeesRecords :many
SELECT
    fees.fees_id,
    students.last_name,
    students.first_name,
    students.middle_name,
    term.name AS AcademicTerm,
    classes.name AS ClassName,
    fee_structure.required AS TuitionAmount,
    fees.paid AS PaidAmount,
    fees.arrears,
    fees.status
FROM fees
INNER JOIN fee_structure 
    ON fees.fee_structure_id = fee_structure.fee_structure_id
INNER JOIN students
    ON fees.student_id = students.student_id
INNER JOIN term
    ON fee_structure.term_id = term.term_id
INNER JOIN classes
    ON fee_structure.class_id = classes.class_id
`

type ListStudentFeesRecordsRow struct {
	FeesID        uuid.UUID      `json:"fees_id"`
	LastName      string         `json:"last_name"`
	FirstName     string         `json:"first_name"`
	MiddleName    pgtype.Text    `json:"middle_name"`
	Academicterm  string         `json:"academicterm"`
	Classname     string         `json:"classname"`
	Tuitionamount pgtype.Numeric `json:"tuitionamount"`
	Paidamount    pgtype.Numeric `json:"paidamount"`
	Arrears       pgtype.Numeric `json:"arrears"`
	Status        string         `json:"status"`
}

func (q *Queries) ListStudentFeesRecords(ctx context.Context) ([]ListStudentFeesRecordsRow, error) {
	rows, err := q.db.Query(ctx, listStudentFeesRecords)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListStudentFeesRecordsRow{}
	for rows.Next() {
		var i ListStudentFeesRecordsRow
		if err := rows.Scan(
			&i.FeesID,
			&i.LastName,
			&i.FirstName,
			&i.MiddleName,
			&i.Academicterm,
			&i.Classname,
			&i.Tuitionamount,
			&i.Paidamount,
			&i.Arrears,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertFeeStructure = `-- name: UpsertFeeStructure :one
INSERT INTO fee_structure (term_id, class_id, required)
VALUES ($1, $2, $3)
ON CONFLICT (term_id, class_id)
  DO UPDATE SET required = EXCLUDED.required
RETURNING fee_structure_id
`

type UpsertFeeStructureParams struct {
	TermID   uuid.UUID      `json:"term_id"`
	ClassID  uuid.UUID      `json:"class_id"`
	Required pgtype.Numeric `json:"required"`
}

func (q *Queries) UpsertFeeStructure(ctx context.Context, arg UpsertFeeStructureParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, upsertFeeStructure, arg.TermID, arg.ClassID, arg.Required)
	var fee_structure_id uuid.UUID
	err := row.Scan(&fee_structure_id)
	return fee_structure_id, err
}
