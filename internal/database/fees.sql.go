// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: fees.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createFeesRecord = `-- name: CreateFeesRecord :one
INSERT INTO fees (fee_structure_id, student_id, paid)
VALUES ($1, $2, $3)
RETURNING fees_id, fee_structure_id, student_id, paid, arrears, status
`

type CreateFeesRecordParams struct {
	FeeStructureID uuid.UUID      `json:"fee_structure_id"`
	StudentID      uuid.UUID      `json:"student_id"`
	Paid           pgtype.Numeric `json:"paid"`
}

func (q *Queries) CreateFeesRecord(ctx context.Context, arg CreateFeesRecordParams) (Fee, error) {
	row := q.db.QueryRow(ctx, createFeesRecord, arg.FeeStructureID, arg.StudentID, arg.Paid)
	var i Fee
	err := row.Scan(
		&i.FeesID,
		&i.FeeStructureID,
		&i.StudentID,
		&i.Paid,
		&i.Arrears,
		&i.Status,
	)
	return i, err
}

const editFeesRecord = `-- name: EditFeesRecord :exec
UPDATE fees
    SET paid = paid + $2
WHERE fees_id = $1
RETURNING fees_id, fee_structure_id, student_id, paid, arrears, status
`

type EditFeesRecordParams struct {
	FeesID uuid.UUID      `json:"fees_id"`
	Paid   pgtype.Numeric `json:"paid"`
}

func (q *Queries) EditFeesRecord(ctx context.Context, arg EditFeesRecordParams) error {
	_, err := q.db.Exec(ctx, editFeesRecord, arg.FeesID, arg.Paid)
	return err
}

const getFeeStructureByTermAndClass = `-- name: GetFeeStructureByTermAndClass :one
SELECT fee_structure_id, term_id, class_id, required
FROM fee_structure
WHERE class_id = $1
AND 
term_id = $2
`

type GetFeeStructureByTermAndClassParams struct {
	ClassID uuid.UUID `json:"class_id"`
	TermID  uuid.UUID `json:"term_id"`
}

func (q *Queries) GetFeeStructureByTermAndClass(ctx context.Context, arg GetFeeStructureByTermAndClassParams) (FeeStructure, error) {
	row := q.db.QueryRow(ctx, getFeeStructureByTermAndClass, arg.ClassID, arg.TermID)
	var i FeeStructure
	err := row.Scan(
		&i.FeeStructureID,
		&i.TermID,
		&i.ClassID,
		&i.Required,
	)
	return i, err
}

const getFeesRecord = `-- name: GetFeesRecord :one
SELECT
    fees.fees_id,
    students.student_id,
    students.last_name,
    students.first_name,
    students.middle_name,
    term.name AS AcademicTerm,
    classes.class_id,
    classes.name AS ClassName,
    fee_structure.required AS TuitionAmount,
    fees.paid AS PaidAmount,
    fees.arrears,
    fees.status
FROM fees
INNER JOIN fee_structure 
    ON fees.fee_structure_id = fee_structure.fee_structure_id
INNER JOIN students
    ON fees.student_id = students.student_id
INNER JOIN term
    ON fee_structure.term_id = term.term_id
INNER JOIN classes
    ON fee_structure.class_id = classes.class_id
WHERE fees.fees_id = $1
`

type GetFeesRecordRow struct {
	FeesID        uuid.UUID      `json:"fees_id"`
	StudentID     uuid.UUID      `json:"student_id"`
	LastName      string         `json:"last_name"`
	FirstName     string         `json:"first_name"`
	MiddleName    pgtype.Text    `json:"middle_name"`
	Academicterm  string         `json:"academicterm"`
	ClassID       uuid.UUID      `json:"class_id"`
	Classname     string         `json:"classname"`
	Tuitionamount pgtype.Numeric `json:"tuitionamount"`
	Paidamount    pgtype.Numeric `json:"paidamount"`
	Arrears       pgtype.Numeric `json:"arrears"`
	Status        string         `json:"status"`
}

func (q *Queries) GetFeesRecord(ctx context.Context, feesID uuid.UUID) (GetFeesRecordRow, error) {
	row := q.db.QueryRow(ctx, getFeesRecord, feesID)
	var i GetFeesRecordRow
	err := row.Scan(
		&i.FeesID,
		&i.StudentID,
		&i.LastName,
		&i.FirstName,
		&i.MiddleName,
		&i.Academicterm,
		&i.ClassID,
		&i.Classname,
		&i.Tuitionamount,
		&i.Paidamount,
		&i.Arrears,
		&i.Status,
	)
	return i, err
}

const listStudentFeesRecords = `-- name: ListStudentFeesRecords :many
SELECT
    f.fees_id,
    s.student_id,
    s.last_name,
    s.first_name,
    s.middle_name,
    t.name AS AcademicTerm,
    c.name AS ClassName,
    fs.class_id,
    fs.required AS TuitionAmount,
    COALESCE(f.paid, 0.00) AS PaidAmount,
    COALESCE(f.arrears, 0.00) AS Arrears,
    COALESCE(f.status, 'OVERDUE') AS Status,
    c.class_id AS ClassID,
    fs.fee_structure_id,
    t.term_id
FROM fee_structure fs
INNER JOIN term t ON fs.term_id = t.term_id
INNER JOIN classes c ON fs.class_id = c.class_id
LEFT JOIN student_classes sc
    ON fs.class_id = sc.class_id
LEFT JOIN students s ON sc.student_id = s.student_id
LEFT JOIN fees f
    ON fs.fee_structure_id = f.fee_structure_id
    AND s.student_id = f.student_id
WHERE t.term_id = $1
`

type ListStudentFeesRecordsRow struct {
	FeesID         pgtype.UUID    `json:"fees_id"`
	StudentID      pgtype.UUID    `json:"student_id"`
	LastName       pgtype.Text    `json:"last_name"`
	FirstName      pgtype.Text    `json:"first_name"`
	MiddleName     pgtype.Text    `json:"middle_name"`
	Academicterm   string         `json:"academicterm"`
	Classname      string         `json:"classname"`
	ClassID        uuid.UUID      `json:"class_id"`
	Tuitionamount  pgtype.Numeric `json:"tuitionamount"`
	Paidamount     pgtype.Numeric `json:"paidamount"`
	Arrears        pgtype.Numeric `json:"arrears"`
	Status         string         `json:"status"`
	Classid        uuid.UUID      `json:"classid"`
	FeeStructureID uuid.UUID      `json:"fee_structure_id"`
	TermID         uuid.UUID      `json:"term_id"`
}

func (q *Queries) ListStudentFeesRecords(ctx context.Context, termID uuid.UUID) ([]ListStudentFeesRecordsRow, error) {
	rows, err := q.db.Query(ctx, listStudentFeesRecords, termID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListStudentFeesRecordsRow{}
	for rows.Next() {
		var i ListStudentFeesRecordsRow
		if err := rows.Scan(
			&i.FeesID,
			&i.StudentID,
			&i.LastName,
			&i.FirstName,
			&i.MiddleName,
			&i.Academicterm,
			&i.Classname,
			&i.ClassID,
			&i.Tuitionamount,
			&i.Paidamount,
			&i.Arrears,
			&i.Status,
			&i.Classid,
			&i.FeeStructureID,
			&i.TermID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStudentsByClassForTerm = `-- name: ListStudentsByClassForTerm :many
SELECT
    s.student_id, s.student_no, s.academic_year_id, s.last_name, s.middle_name, s.first_name, s.gender, s.date_of_birth, s.status, s.promoted, s.graduated, s.suspended
FROM students s
INNER JOIN student_classes sc ON s.student_id = sc.student_id
INNER JOIN term t ON sc.term_id = t.term_id
INNER JOIN classes c ON sc.class_id = c.class_id
WHERE c.class_id = $1 AND t.active = TRUE
`

func (q *Queries) ListStudentsByClassForTerm(ctx context.Context, classID uuid.UUID) ([]Student, error) {
	rows, err := q.db.Query(ctx, listStudentsByClassForTerm, classID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Student{}
	for rows.Next() {
		var i Student
		if err := rows.Scan(
			&i.StudentID,
			&i.StudentNo,
			&i.AcademicYearID,
			&i.LastName,
			&i.MiddleName,
			&i.FirstName,
			&i.Gender,
			&i.DateOfBirth,
			&i.Status,
			&i.Promoted,
			&i.Graduated,
			&i.Suspended,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const transferAreas = `-- name: TransferAreas :exec
INSERT INTO fees (fee_structure_id, student_id, paid,  arrears)
VALUES ($1, $2, $3, $4)
RETURNING fees_id, fee_structure_id, student_id, paid, arrears, status
`

type TransferAreasParams struct {
	FeeStructureID uuid.UUID      `json:"fee_structure_id"`
	StudentID      uuid.UUID      `json:"student_id"`
	Paid           pgtype.Numeric `json:"paid"`
	Arrears        pgtype.Numeric `json:"arrears"`
}

func (q *Queries) TransferAreas(ctx context.Context, arg TransferAreasParams) error {
	_, err := q.db.Exec(ctx, transferAreas,
		arg.FeeStructureID,
		arg.StudentID,
		arg.Paid,
		arg.Arrears,
	)
	return err
}

const upsertFeeStructure = `-- name: UpsertFeeStructure :one
INSERT INTO fee_structure (term_id, class_id, required)
VALUES ($1, $2, $3)
ON CONFLICT (term_id, class_id)
  DO UPDATE SET required = EXCLUDED.required
RETURNING fee_structure_id
`

type UpsertFeeStructureParams struct {
	TermID   uuid.UUID      `json:"term_id"`
	ClassID  uuid.UUID      `json:"class_id"`
	Required pgtype.Numeric `json:"required"`
}

func (q *Queries) UpsertFeeStructure(ctx context.Context, arg UpsertFeeStructureParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, upsertFeeStructure, arg.TermID, arg.ClassID, arg.Required)
	var fee_structure_id uuid.UUID
	err := row.Scan(&fee_structure_id)
	return fee_structure_id, err
}
