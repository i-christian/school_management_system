// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: fees.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createFeesRecord = `-- name: CreateFeesRecord :one
INSERT INTO fees (fee_structure_id, student_id, paid)
VALUES ('42edfb67-d132-4257-8460-3731d32887f5', 'fec78aac-0577-46b9-b300-905fc384d055', 200000)
RETURNING fees_id, fee_structure_id, student_id, paid, arrears, status
`

func (q *Queries) CreateFeesRecord(ctx context.Context) (Fee, error) {
	row := q.db.QueryRow(ctx, createFeesRecord)
	var i Fee
	err := row.Scan(
		&i.FeesID,
		&i.FeeStructureID,
		&i.StudentID,
		&i.Paid,
		&i.Arrears,
		&i.Status,
	)
	return i, err
}

const editFeesRecord = `-- name: EditFeesRecord :exec
UPDATE fees
    SET paid = COALESCE($2, paid)
WHERE fees_id = $1
`

type EditFeesRecordParams struct {
	FeesID uuid.UUID      `json:"fees_id"`
	Paid   pgtype.Numeric `json:"paid"`
}

func (q *Queries) EditFeesRecord(ctx context.Context, arg EditFeesRecordParams) error {
	_, err := q.db.Exec(ctx, editFeesRecord, arg.FeesID, arg.Paid)
	return err
}

const getStudentFeesRecord = `-- name: GetStudentFeesRecord :one
SELECT
    fees.fees_id,
    students.last_name,
    students.first_name,
    students.middle_name,
    term.name AS AcademicTerm,
    classes.name AS ClassName,
    fee_structure.required AS TuitionAmount,
    fees.paid AS PaidAmount,
    fees.arrears,
    fees.status
FROM fees
INNER JOIN fee_structure 
    ON fees.fee_structure_id = fee_structure.fee_structure_id
INNER JOIN students
    ON fees.student_id = students.student_id
INNER JOIN term
    ON fee_structure.term_id = term.term_id
INNER JOIN classes
    ON fee_structure.class_id = classes.class_id
WHERE students.student_id = $1
`

type GetStudentFeesRecordRow struct {
	FeesID        uuid.UUID      `json:"fees_id"`
	LastName      string         `json:"last_name"`
	FirstName     string         `json:"first_name"`
	MiddleName    pgtype.Text    `json:"middle_name"`
	Academicterm  string         `json:"academicterm"`
	Classname     string         `json:"classname"`
	Tuitionamount pgtype.Numeric `json:"tuitionamount"`
	Paidamount    pgtype.Numeric `json:"paidamount"`
	Arrears       pgtype.Numeric `json:"arrears"`
	Status        string         `json:"status"`
}

func (q *Queries) GetStudentFeesRecord(ctx context.Context, studentID uuid.UUID) (GetStudentFeesRecordRow, error) {
	row := q.db.QueryRow(ctx, getStudentFeesRecord, studentID)
	var i GetStudentFeesRecordRow
	err := row.Scan(
		&i.FeesID,
		&i.LastName,
		&i.FirstName,
		&i.MiddleName,
		&i.Academicterm,
		&i.Classname,
		&i.Tuitionamount,
		&i.Paidamount,
		&i.Arrears,
		&i.Status,
	)
	return i, err
}

const listStudentFeesRecords = `-- name: ListStudentFeesRecords :many
SELECT
    fees.fees_id,
    students.last_name,
    students.first_name,
    students.middle_name,
    term.name AS AcademicTerm,
    classes.name AS ClassName,
    fee_structure.required AS TuitionAmount,
    fees.paid AS PaidAmount,
    fees.arrears,
    fees.status
FROM fees
INNER JOIN fee_structure 
    ON fees.fee_structure_id = fee_structure.fee_structure_id
INNER JOIN students
    ON fees.student_id = students.student_id
INNER JOIN term
    ON fee_structure.term_id = term.term_id
INNER JOIN classes
    ON fee_structure.class_id = classes.class_id
`

type ListStudentFeesRecordsRow struct {
	FeesID        uuid.UUID      `json:"fees_id"`
	LastName      string         `json:"last_name"`
	FirstName     string         `json:"first_name"`
	MiddleName    pgtype.Text    `json:"middle_name"`
	Academicterm  string         `json:"academicterm"`
	Classname     string         `json:"classname"`
	Tuitionamount pgtype.Numeric `json:"tuitionamount"`
	Paidamount    pgtype.Numeric `json:"paidamount"`
	Arrears       pgtype.Numeric `json:"arrears"`
	Status        string         `json:"status"`
}

func (q *Queries) ListStudentFeesRecords(ctx context.Context) ([]ListStudentFeesRecordsRow, error) {
	rows, err := q.db.Query(ctx, listStudentFeesRecords)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListStudentFeesRecordsRow{}
	for rows.Next() {
		var i ListStudentFeesRecordsRow
		if err := rows.Scan(
			&i.FeesID,
			&i.LastName,
			&i.FirstName,
			&i.MiddleName,
			&i.Academicterm,
			&i.Classname,
			&i.Tuitionamount,
			&i.Paidamount,
			&i.Arrears,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFeesArrears = `-- name: UpdateFeesArrears :exec
WITH previous_fees_arrears AS (
    SELECT
        f.student_id,
        fs.required - f.paid AS term_arrears
    FROM fees f
    JOIN fee_structure fs ON f.fee_structure_id = fs.fee_structure_id
    WHERE fs.term_id = $1 -- Previous term ID
)
UPDATE fees AS current_fees
SET arrears = COALESCE(current_fees.arrears, 0) + COALESCE(previous_fees_arrears.term_arrears, 0)
FROM previous_fees_arrears
WHERE current_fees.student_id = previous_fees_arrears.student_id
`

func (q *Queries) UpdateFeesArrears(ctx context.Context, termID uuid.UUID) error {
	_, err := q.db.Exec(ctx, updateFeesArrears, termID)
	return err
}

const upsertFeeStructure = `-- name: UpsertFeeStructure :one
INSERT INTO fee_structure (term_id, class_id, required)
VALUES ('2b9fd9bb-d8a8-4d91-bf86-887148316cdf', '5eed0744-a86f-4426-9188-0a09f6d127d5', 500000)
ON CONFLICT (term_id, class_id)
  DO UPDATE SET required = EXCLUDED.required
RETURNING fee_structure_id
`

func (q *Queries) UpsertFeeStructure(ctx context.Context) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, upsertFeeStructure)
	var fee_structure_id uuid.UUID
	err := row.Scan(&fee_structure_id)
	return fee_structure_id, err
}
