// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: academic_year.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createAcademicYear = `-- name: CreateAcademicYear :one
INSERT INTO academic_year (name, start_date, end_date, graduate_class_id) 
VALUES ($1, $2, $3, $4)
ON CONFLICT (name) DO NOTHING
RETURNING academic_year_id
`

type CreateAcademicYearParams struct {
	Name            string      `json:"name"`
	StartDate       pgtype.Date `json:"start_date"`
	EndDate         pgtype.Date `json:"end_date"`
	GraduateClassID pgtype.UUID `json:"graduate_class_id"`
}

func (q *Queries) CreateAcademicYear(ctx context.Context, arg CreateAcademicYearParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createAcademicYear,
		arg.Name,
		arg.StartDate,
		arg.EndDate,
		arg.GraduateClassID,
	)
	var academic_year_id uuid.UUID
	err := row.Scan(&academic_year_id)
	return academic_year_id, err
}

const createTerm = `-- name: CreateTerm :one
INSERT INTO term (academic_year_id, name, start_date, end_date) 
VALUES ($1, $2, $3, $4)
ON CONFLICT ON CONSTRAINT term_name_on_academic_year DO NOTHING 
RETURNING term_id
`

type CreateTermParams struct {
	AcademicYearID uuid.UUID   `json:"academic_year_id"`
	Name           string      `json:"name"`
	StartDate      pgtype.Date `json:"start_date"`
	EndDate        pgtype.Date `json:"end_date"`
}

func (q *Queries) CreateTerm(ctx context.Context, arg CreateTermParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createTerm,
		arg.AcademicYearID,
		arg.Name,
		arg.StartDate,
		arg.EndDate,
	)
	var term_id uuid.UUID
	err := row.Scan(&term_id)
	return term_id, err
}

const deactivateAcademicYear = `-- name: DeactivateAcademicYear :exec
UPDATE academic_year
SET active = FALSE
WHERE active = TRUE
`

func (q *Queries) DeactivateAcademicYear(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deactivateAcademicYear)
	return err
}

const deactivateTerm = `-- name: DeactivateTerm :one
UPDATE term
SET active = FALSE
WHERE active = TRUE
RETURNING term_id
`

func (q *Queries) DeactivateTerm(ctx context.Context) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, deactivateTerm)
	var term_id uuid.UUID
	err := row.Scan(&term_id)
	return term_id, err
}

const deleteAcademicYear = `-- name: DeleteAcademicYear :exec
DELETE FROM academic_year
WHERE academic_year_id = $1
`

func (q *Queries) DeleteAcademicYear(ctx context.Context, academicYearID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAcademicYear, academicYearID)
	return err
}

const deleteTerm = `-- name: DeleteTerm :exec
DELETE FROM term
WHERE term_id = $1
`

func (q *Queries) DeleteTerm(ctx context.Context, termID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteTerm, termID)
	return err
}

const editAcademicYear = `-- name: EditAcademicYear :exec
UPDATE academic_year
    SET name = COALESCE($1, name),
    start_date = COALESCE($2, start_date),
    end_date = COALESCE($3, end_date)
WHERE academic_year_id = $4
`

type EditAcademicYearParams struct {
	Name           string      `json:"name"`
	StartDate      pgtype.Date `json:"start_date"`
	EndDate        pgtype.Date `json:"end_date"`
	AcademicYearID uuid.UUID   `json:"academic_year_id"`
}

func (q *Queries) EditAcademicYear(ctx context.Context, arg EditAcademicYearParams) error {
	_, err := q.db.Exec(ctx, editAcademicYear,
		arg.Name,
		arg.StartDate,
		arg.EndDate,
		arg.AcademicYearID,
	)
	return err
}

const editTerm = `-- name: EditTerm :exec
UPDATE term 
SET name = COALESCE($2, name),
start_date = COALESCE($3, start_date),
end_date = COALESCE($4, end_date)
WHERE term_id = $1
`

type EditTermParams struct {
	TermID    uuid.UUID   `json:"term_id"`
	Name      string      `json:"name"`
	StartDate pgtype.Date `json:"start_date"`
	EndDate   pgtype.Date `json:"end_date"`
}

func (q *Queries) EditTerm(ctx context.Context, arg EditTermParams) error {
	_, err := q.db.Exec(ctx, editTerm,
		arg.TermID,
		arg.Name,
		arg.StartDate,
		arg.EndDate,
	)
	return err
}

const getAcademicYear = `-- name: GetAcademicYear :one
SELECT academic_year_id, graduate_class_id, name, start_date, end_date, active, period FROM academic_year WHERE academic_year_id = $1
`

func (q *Queries) GetAcademicYear(ctx context.Context, academicYearID uuid.UUID) (AcademicYear, error) {
	row := q.db.QueryRow(ctx, getAcademicYear, academicYearID)
	var i AcademicYear
	err := row.Scan(
		&i.AcademicYearID,
		&i.GraduateClassID,
		&i.Name,
		&i.StartDate,
		&i.EndDate,
		&i.Active,
		&i.Period,
	)
	return i, err
}

const getCurrentAcademicYear = `-- name: GetCurrentAcademicYear :one
SELECT academic_year_id, graduate_class_id, name, start_date, end_date, active, period
FROM academic_year
WHERE active = TRUE
LIMIT 1
`

func (q *Queries) GetCurrentAcademicYear(ctx context.Context) (AcademicYear, error) {
	row := q.db.QueryRow(ctx, getCurrentAcademicYear)
	var i AcademicYear
	err := row.Scan(
		&i.AcademicYearID,
		&i.GraduateClassID,
		&i.Name,
		&i.StartDate,
		&i.EndDate,
		&i.Active,
		&i.Period,
	)
	return i, err
}

const getCurrentAcademicYearAndTerm = `-- name: GetCurrentAcademicYearAndTerm :one
SELECT
    ay.academic_year_id,
    ay.name AS Academic_Year,
    ay.start_date,
    ay.end_date,
    t.term_id,
    t.name AS Academic_Term,
    t.start_date AS Term_Opening_date,
    t.end_date AS Term_Closing_date
FROM academic_year ay
LEFT JOIN term t
    ON ay.academic_year_id = t.academic_year_id
    AND t.active = TRUE
WHERE ay.active = TRUE
LIMIT 1
`

type GetCurrentAcademicYearAndTermRow struct {
	AcademicYearID  uuid.UUID   `json:"academic_year_id"`
	AcademicYear    string      `json:"academic_year"`
	StartDate       pgtype.Date `json:"start_date"`
	EndDate         pgtype.Date `json:"end_date"`
	TermID          pgtype.UUID `json:"term_id"`
	AcademicTerm    pgtype.Text `json:"academic_term"`
	TermOpeningDate pgtype.Date `json:"term_opening_date"`
	TermClosingDate pgtype.Date `json:"term_closing_date"`
}

func (q *Queries) GetCurrentAcademicYearAndTerm(ctx context.Context) (GetCurrentAcademicYearAndTermRow, error) {
	row := q.db.QueryRow(ctx, getCurrentAcademicYearAndTerm)
	var i GetCurrentAcademicYearAndTermRow
	err := row.Scan(
		&i.AcademicYearID,
		&i.AcademicYear,
		&i.StartDate,
		&i.EndDate,
		&i.TermID,
		&i.AcademicTerm,
		&i.TermOpeningDate,
		&i.TermClosingDate,
	)
	return i, err
}

const getCurrentTerm = `-- name: GetCurrentTerm :one
SELECT
    t.term_id,
    t.previous_term_id,
    ay.academic_year_id,
    ay.name AS Academic_Year,
    t.name AS Academic_Term,
    t.start_date AS Opening_date,
    t.end_date AS Closing_date
FROM term t
INNER JOIN academic_year ay
    ON t.academic_year_id = ay.academic_year_id
WHERE t.active = TRUE
LIMIT 1
`

type GetCurrentTermRow struct {
	TermID         uuid.UUID   `json:"term_id"`
	PreviousTermID pgtype.UUID `json:"previous_term_id"`
	AcademicYearID uuid.UUID   `json:"academic_year_id"`
	AcademicYear   string      `json:"academic_year"`
	AcademicTerm   string      `json:"academic_term"`
	OpeningDate    pgtype.Date `json:"opening_date"`
	ClosingDate    pgtype.Date `json:"closing_date"`
}

func (q *Queries) GetCurrentTerm(ctx context.Context) (GetCurrentTermRow, error) {
	row := q.db.QueryRow(ctx, getCurrentTerm)
	var i GetCurrentTermRow
	err := row.Scan(
		&i.TermID,
		&i.PreviousTermID,
		&i.AcademicYearID,
		&i.AcademicYear,
		&i.AcademicTerm,
		&i.OpeningDate,
		&i.ClosingDate,
	)
	return i, err
}

const getTerm = `-- name: GetTerm :one
SELECT
term.term_id,
academic_year.academic_year_id,
academic_year.name AS Academic_Year,
term.name AS Academic_Term,
term.start_date AS Opening_date,
term.end_date AS Closing_date
FROM term
INNER JOIN academic_year
ON
term.academic_year_id = academic_year.academic_year_id
WHERE term_id = $1
`

type GetTermRow struct {
	TermID         uuid.UUID   `json:"term_id"`
	AcademicYearID uuid.UUID   `json:"academic_year_id"`
	AcademicYear   string      `json:"academic_year"`
	AcademicTerm   string      `json:"academic_term"`
	OpeningDate    pgtype.Date `json:"opening_date"`
	ClosingDate    pgtype.Date `json:"closing_date"`
}

func (q *Queries) GetTerm(ctx context.Context, termID uuid.UUID) (GetTermRow, error) {
	row := q.db.QueryRow(ctx, getTerm, termID)
	var i GetTermRow
	err := row.Scan(
		&i.TermID,
		&i.AcademicYearID,
		&i.AcademicYear,
		&i.AcademicTerm,
		&i.OpeningDate,
		&i.ClosingDate,
	)
	return i, err
}

const listAcademicYear = `-- name: ListAcademicYear :many
SELECT academic_year_id, graduate_class_id, name, start_date, end_date, active, period FROM academic_year
ORDER BY active DESC
`

func (q *Queries) ListAcademicYear(ctx context.Context) ([]AcademicYear, error) {
	rows, err := q.db.Query(ctx, listAcademicYear)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AcademicYear{}
	for rows.Next() {
		var i AcademicYear
		if err := rows.Scan(
			&i.AcademicYearID,
			&i.GraduateClassID,
			&i.Name,
			&i.StartDate,
			&i.EndDate,
			&i.Active,
			&i.Period,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTerms = `-- name: ListTerms :many
SELECT
term.term_id,
academic_year.academic_year_id,
academic_year.name AS Academic_Year,
term.name AS Academic_Term,
term.start_date AS Opening_date,
term.end_date AS Closing_date,
term.active
FROM term
INNER JOIN academic_year
ON
term.academic_year_id = academic_year.academic_year_id
WHERE academic_year.academic_year_id = $1
ORDER BY term.active DESC
`

type ListTermsRow struct {
	TermID         uuid.UUID   `json:"term_id"`
	AcademicYearID uuid.UUID   `json:"academic_year_id"`
	AcademicYear   string      `json:"academic_year"`
	AcademicTerm   string      `json:"academic_term"`
	OpeningDate    pgtype.Date `json:"opening_date"`
	ClosingDate    pgtype.Date `json:"closing_date"`
	Active         bool        `json:"active"`
}

func (q *Queries) ListTerms(ctx context.Context, academicYearID uuid.UUID) ([]ListTermsRow, error) {
	rows, err := q.db.Query(ctx, listTerms, academicYearID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTermsRow{}
	for rows.Next() {
		var i ListTermsRow
		if err := rows.Scan(
			&i.TermID,
			&i.AcademicYearID,
			&i.AcademicYear,
			&i.AcademicTerm,
			&i.OpeningDate,
			&i.ClosingDate,
			&i.Active,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setCurrentAcademicYear = `-- name: SetCurrentAcademicYear :exec
UPDATE academic_year
SET active = TRUE
WHERE academic_year_id = $1
`

func (q *Queries) SetCurrentAcademicYear(ctx context.Context, academicYearID uuid.UUID) error {
	_, err := q.db.Exec(ctx, setCurrentAcademicYear, academicYearID)
	return err
}

const setCurrentTerm = `-- name: SetCurrentTerm :exec
UPDATE term
SET active = TRUE, previous_term_id = $2
WHERE term_id = $1
`

type SetCurrentTermParams struct {
	TermID         uuid.UUID   `json:"term_id"`
	PreviousTermID pgtype.UUID `json:"previous_term_id"`
}

func (q *Queries) SetCurrentTerm(ctx context.Context, arg SetCurrentTermParams) error {
	_, err := q.db.Exec(ctx, setCurrentTerm, arg.TermID, arg.PreviousTermID)
	return err
}
