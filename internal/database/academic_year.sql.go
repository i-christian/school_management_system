// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: academic_year.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createAcademicYear = `-- name: CreateAcademicYear :one
INSERT INTO academic_year (name, start_date, end_date) 
VALUES ($1, $2, $3)
ON CONFLICT (name) DO NOTHING
RETURNING academic_year_id
`

type CreateAcademicYearParams struct {
	Name      string      `json:"name"`
	StartDate pgtype.Date `json:"start_date"`
	EndDate   pgtype.Date `json:"end_date"`
}

func (q *Queries) CreateAcademicYear(ctx context.Context, arg CreateAcademicYearParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createAcademicYear, arg.Name, arg.StartDate, arg.EndDate)
	var academic_year_id uuid.UUID
	err := row.Scan(&academic_year_id)
	return academic_year_id, err
}

const createTerm = `-- name: CreateTerm :one
INSERT INTO term (academic_year_id, name, start_date, end_date) 
VALUES ($1, $2, $3, $4)
ON CONFLICT ON CONSTRAINT term_name_on_academic_year DO NOTHING 
RETURNING term_id
`

type CreateTermParams struct {
	AcademicYearID uuid.UUID   `json:"academic_year_id"`
	Name           string      `json:"name"`
	StartDate      pgtype.Date `json:"start_date"`
	EndDate        pgtype.Date `json:"end_date"`
}

func (q *Queries) CreateTerm(ctx context.Context, arg CreateTermParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createTerm,
		arg.AcademicYearID,
		arg.Name,
		arg.StartDate,
		arg.EndDate,
	)
	var term_id uuid.UUID
	err := row.Scan(&term_id)
	return term_id, err
}

const deleteAcademicYear = `-- name: DeleteAcademicYear :exec
DELETE FROM academic_year
WHERE academic_year_id = $1
`

func (q *Queries) DeleteAcademicYear(ctx context.Context, academicYearID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAcademicYear, academicYearID)
	return err
}

const deleteTerm = `-- name: DeleteTerm :exec
DELETE FROM term
WHERE term_id = $1
`

func (q *Queries) DeleteTerm(ctx context.Context, termID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteTerm, termID)
	return err
}

const editAcademicYear = `-- name: EditAcademicYear :exec
UPDATE academic_year
    SET name = COALESCE($1, name),
    start_date = COALESCE($2, start_date),
    end_date = COALESCE($3, end_date)
WHERE academic_year_id = $4
`

type EditAcademicYearParams struct {
	Name           string      `json:"name"`
	StartDate      pgtype.Date `json:"start_date"`
	EndDate        pgtype.Date `json:"end_date"`
	AcademicYearID uuid.UUID   `json:"academic_year_id"`
}

func (q *Queries) EditAcademicYear(ctx context.Context, arg EditAcademicYearParams) error {
	_, err := q.db.Exec(ctx, editAcademicYear,
		arg.Name,
		arg.StartDate,
		arg.EndDate,
		arg.AcademicYearID,
	)
	return err
}

const editTerm = `-- name: EditTerm :exec
UPDATE term 
SET name = COALESCE($2, name),
start_date = COALESCE($3, start_date),
end_date = COALESCE($4, end_date)
WHERE term_id = $1
`

type EditTermParams struct {
	TermID    uuid.UUID   `json:"term_id"`
	Name      string      `json:"name"`
	StartDate pgtype.Date `json:"start_date"`
	EndDate   pgtype.Date `json:"end_date"`
}

func (q *Queries) EditTerm(ctx context.Context, arg EditTermParams) error {
	_, err := q.db.Exec(ctx, editTerm,
		arg.TermID,
		arg.Name,
		arg.StartDate,
		arg.EndDate,
	)
	return err
}

const getAcademicYear = `-- name: GetAcademicYear :one
SELECT academic_year_id, name, start_date, end_date FROM academic_year WHERE academic_year_id = $1
`

func (q *Queries) GetAcademicYear(ctx context.Context, academicYearID uuid.UUID) (AcademicYear, error) {
	row := q.db.QueryRow(ctx, getAcademicYear, academicYearID)
	var i AcademicYear
	err := row.Scan(
		&i.AcademicYearID,
		&i.Name,
		&i.StartDate,
		&i.EndDate,
	)
	return i, err
}

const getTerm = `-- name: GetTerm :one
SELECT
term.term_id,
academic_year.academic_year_id,
academic_year.name AS Academic_Year,
term.name AS Academic_Term,
term.start_date AS Opening_date,
term.end_date AS Closing_date
FROM term
INNER JOIN academic_year
ON
term.academic_year_id = academic_year.academic_year_id
WHERE term_id = $1
`

type GetTermRow struct {
	TermID         uuid.UUID   `json:"term_id"`
	AcademicYearID uuid.UUID   `json:"academic_year_id"`
	AcademicYear   string      `json:"academic_year"`
	AcademicTerm   string      `json:"academic_term"`
	OpeningDate    pgtype.Date `json:"opening_date"`
	ClosingDate    pgtype.Date `json:"closing_date"`
}

func (q *Queries) GetTerm(ctx context.Context, termID uuid.UUID) (GetTermRow, error) {
	row := q.db.QueryRow(ctx, getTerm, termID)
	var i GetTermRow
	err := row.Scan(
		&i.TermID,
		&i.AcademicYearID,
		&i.AcademicYear,
		&i.AcademicTerm,
		&i.OpeningDate,
		&i.ClosingDate,
	)
	return i, err
}

const listAcademicYear = `-- name: ListAcademicYear :many
SELECT academic_year_id, name, start_date, end_date FROM academic_year
`

func (q *Queries) ListAcademicYear(ctx context.Context) ([]AcademicYear, error) {
	rows, err := q.db.Query(ctx, listAcademicYear)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AcademicYear{}
	for rows.Next() {
		var i AcademicYear
		if err := rows.Scan(
			&i.AcademicYearID,
			&i.Name,
			&i.StartDate,
			&i.EndDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTerms = `-- name: ListTerms :many
SELECT
term.term_id,
academic_year.name AS Academic_Year,
term.name AS Academic_Term,
term.start_date AS Opening_date,
term.end_date AS Closing_date
FROM term
INNER JOIN academic_year
ON
term.academic_year_id = academic_year.academic_year_id
WHERE academic_year.academic_year_id = $1
`

type ListTermsRow struct {
	TermID       uuid.UUID   `json:"term_id"`
	AcademicYear string      `json:"academic_year"`
	AcademicTerm string      `json:"academic_term"`
	OpeningDate  pgtype.Date `json:"opening_date"`
	ClosingDate  pgtype.Date `json:"closing_date"`
}

func (q *Queries) ListTerms(ctx context.Context, academicYearID uuid.UUID) ([]ListTermsRow, error) {
	rows, err := q.db.Query(ctx, listTerms, academicYearID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTermsRow{}
	for rows.Next() {
		var i ListTermsRow
		if err := rows.Scan(
			&i.TermID,
			&i.AcademicYear,
			&i.AcademicTerm,
			&i.OpeningDate,
			&i.ClosingDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
