// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: remarks.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const deleteRemark = `-- name: DeleteRemark :exec
DELETE FROM remarks WHERE remarks_id = $1
`

func (q *Queries) DeleteRemark(ctx context.Context, remarksID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteRemark, remarksID)
	return err
}

const getRemark = `-- name: GetRemark :one
SELECT
    remarks.remarks_id,
    students.last_name,
    students.first_name,
    term.name AS AcademicTerm,
    remarks.content_class_teacher AS ClassTeacherRemarks,
    remarks.content_head_teacher AS HeadTeacherRemarks,
    remarks.updated_at
FROM remarks
INNER JOIN students 
    ON remarks.student_id = students.student_id
INNER JOIN term
    ON remarks.term_id = term.term_id
WHERE students.student_id = $1
`

type GetRemarkRow struct {
	RemarksID           uuid.UUID          `json:"remarks_id"`
	LastName            string             `json:"last_name"`
	FirstName           string             `json:"first_name"`
	Academicterm        string             `json:"academicterm"`
	Classteacherremarks pgtype.Text        `json:"classteacherremarks"`
	Headteacherremarks  pgtype.Text        `json:"headteacherremarks"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetRemark(ctx context.Context, studentID uuid.UUID) (GetRemarkRow, error) {
	row := q.db.QueryRow(ctx, getRemark, studentID)
	var i GetRemarkRow
	err := row.Scan(
		&i.RemarksID,
		&i.LastName,
		&i.FirstName,
		&i.Academicterm,
		&i.Classteacherremarks,
		&i.Headteacherremarks,
		&i.UpdatedAt,
	)
	return i, err
}

const listRemarks = `-- name: ListRemarks :many
SELECT
    remarks.remarks_id,
    students.last_name,
    students.first_name,
    students.middle_name,
    term.name AS AcademicTerm,
    remarks.content_class_teacher AS ClassTeacherRemarks,
    remarks.content_head_teacher AS HeadTeacherRemarks,
    remarks.updated_at
FROM remarks
INNER JOIN students 
    ON remarks.student_id = students.student_id
INNER JOIN term
    ON remarks.term_id = term.term_id
`

type ListRemarksRow struct {
	RemarksID           uuid.UUID          `json:"remarks_id"`
	LastName            string             `json:"last_name"`
	FirstName           string             `json:"first_name"`
	MiddleName          pgtype.Text        `json:"middle_name"`
	Academicterm        string             `json:"academicterm"`
	Classteacherremarks pgtype.Text        `json:"classteacherremarks"`
	Headteacherremarks  pgtype.Text        `json:"headteacherremarks"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) ListRemarks(ctx context.Context) ([]ListRemarksRow, error) {
	rows, err := q.db.Query(ctx, listRemarks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRemarksRow{}
	for rows.Next() {
		var i ListRemarksRow
		if err := rows.Scan(
			&i.RemarksID,
			&i.LastName,
			&i.FirstName,
			&i.MiddleName,
			&i.Academicterm,
			&i.Classteacherremarks,
			&i.Headteacherremarks,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertRemark = `-- name: UpsertRemark :one
INSERT INTO remarks (student_id, term_id, content_class_teacher, content_head_teacher)
VALUES ($1, $2, $3, $4)
ON CONFLICT (student_id, term_id) DO UPDATE
  SET content_class_teacher = EXCLUDED.content_class_teacher,
      content_head_teacher   = EXCLUDED.content_head_teacher,
      updated_at           = CURRENT_TIMESTAMP
RETURNING remarks_id, student_id, term_id, content_class_teacher, content_head_teacher, updated_at
`

type UpsertRemarkParams struct {
	StudentID           uuid.UUID   `json:"student_id"`
	TermID              uuid.UUID   `json:"term_id"`
	ContentClassTeacher pgtype.Text `json:"content_class_teacher"`
	ContentHeadTeacher  pgtype.Text `json:"content_head_teacher"`
}

func (q *Queries) UpsertRemark(ctx context.Context, arg UpsertRemarkParams) (Remark, error) {
	row := q.db.QueryRow(ctx, upsertRemark,
		arg.StudentID,
		arg.TermID,
		arg.ContentClassTeacher,
		arg.ContentHeadTeacher,
	)
	var i Remark
	err := row.Scan(
		&i.RemarksID,
		&i.StudentID,
		&i.TermID,
		&i.ContentClassTeacher,
		&i.ContentHeadTeacher,
		&i.UpdatedAt,
	)
	return i, err
}
