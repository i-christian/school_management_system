// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: remarks.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const listRemarksByClass = `-- name: ListRemarksByClass :many
SELECT
  c.name AS class_name,
  s.student_no,
  s.student_id,
  s.last_name,
  s.first_name,
  s.middle_name,
  t.name AS academic_term,
  r.remarks_id,
  r.content_class_teacher AS class_teacher_remarks,
  r.content_head_teacher AS head_teacher_remarks,
  r.updated_at
FROM student_classes sc
INNER JOIN students s 
    ON sc.student_id = s.student_id
INNER JOIN classes c 
    ON sc.class_id = c.class_id
INNER JOIN class_teachers ct
    ON c.class_id = ct.class_id
INNER JOIN users u
    ON ct.teacher_id = u.user_id
    AND u.user_id = $1
INNER JOIN term t 
    ON sc.term_id = t.term_id
LEFT JOIN remarks r 
    ON s.student_id = r.student_id 
   AND sc.term_id = $2
ORDER BY c.name, s.last_name, s.first_name
`

type ListRemarksByClassParams struct {
	UserID uuid.UUID `json:"user_id"`
	TermID uuid.UUID `json:"term_id"`
}

type ListRemarksByClassRow struct {
	ClassName           string             `json:"class_name"`
	StudentNo           string             `json:"student_no"`
	StudentID           uuid.UUID          `json:"student_id"`
	LastName            string             `json:"last_name"`
	FirstName           string             `json:"first_name"`
	MiddleName          pgtype.Text        `json:"middle_name"`
	AcademicTerm        string             `json:"academic_term"`
	RemarksID           pgtype.UUID        `json:"remarks_id"`
	ClassTeacherRemarks pgtype.Text        `json:"class_teacher_remarks"`
	HeadTeacherRemarks  pgtype.Text        `json:"head_teacher_remarks"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) ListRemarksByClass(ctx context.Context, arg ListRemarksByClassParams) ([]ListRemarksByClassRow, error) {
	rows, err := q.db.Query(ctx, listRemarksByClass, arg.UserID, arg.TermID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRemarksByClassRow{}
	for rows.Next() {
		var i ListRemarksByClassRow
		if err := rows.Scan(
			&i.ClassName,
			&i.StudentNo,
			&i.StudentID,
			&i.LastName,
			&i.FirstName,
			&i.MiddleName,
			&i.AcademicTerm,
			&i.RemarksID,
			&i.ClassTeacherRemarks,
			&i.HeadTeacherRemarks,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertRemark = `-- name: UpsertRemark :one
INSERT INTO remarks (student_id, term_id, content_class_teacher, content_head_teacher)
VALUES ($1, $2, $3, $4)
ON CONFLICT (student_id, term_id) DO UPDATE
  SET content_class_teacher = EXCLUDED.content_class_teacher,
      content_head_teacher   = EXCLUDED.content_head_teacher,
      updated_at           = CURRENT_TIMESTAMP
RETURNING remarks_id, student_id, term_id, content_class_teacher, content_head_teacher, updated_at
`

type UpsertRemarkParams struct {
	StudentID           uuid.UUID   `json:"student_id"`
	TermID              uuid.UUID   `json:"term_id"`
	ContentClassTeacher pgtype.Text `json:"content_class_teacher"`
	ContentHeadTeacher  pgtype.Text `json:"content_head_teacher"`
}

func (q *Queries) UpsertRemark(ctx context.Context, arg UpsertRemarkParams) (Remark, error) {
	row := q.db.QueryRow(ctx, upsertRemark,
		arg.StudentID,
		arg.TermID,
		arg.ContentClassTeacher,
		arg.ContentHeadTeacher,
	)
	var i Remark
	err := row.Scan(
		&i.RemarksID,
		&i.StudentID,
		&i.TermID,
		&i.ContentClassTeacher,
		&i.ContentHeadTeacher,
		&i.UpdatedAt,
	)
	return i, err
}
