// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: disciplinary.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const listDisciplinaryRecords = `-- name: ListDisciplinaryRecords :many
SELECT 
    dr.discipline_id,
    s.last_name,
    s.middle_name,
    s.first_name,
    dr.date,
    dr.description AS offense,
    dr.action_taken,
    dr.notes,
    t.name AS term_name,
    u.last_name AS reporter_last_name,
    u.first_name AS reporter_first_name  
FROM discipline_records dr
INNER JOIN students s ON dr.student_id = s.student_id
LEFT JOIN users u ON dr.reported_by = u.user_id
INNER JOIN term t ON dr.term_id = t.term_id
ORDER BY dr.date DESC
`

type ListDisciplinaryRecordsRow struct {
	DisciplineID      uuid.UUID   `json:"discipline_id"`
	LastName          string      `json:"last_name"`
	MiddleName        pgtype.Text `json:"middle_name"`
	FirstName         string      `json:"first_name"`
	Date              pgtype.Date `json:"date"`
	Offense           string      `json:"offense"`
	ActionTaken       pgtype.Text `json:"action_taken"`
	Notes             pgtype.Text `json:"notes"`
	TermName          string      `json:"term_name"`
	ReporterLastName  pgtype.Text `json:"reporter_last_name"`
	ReporterFirstName pgtype.Text `json:"reporter_first_name"`
}

func (q *Queries) ListDisciplinaryRecords(ctx context.Context) ([]ListDisciplinaryRecordsRow, error) {
	rows, err := q.db.Query(ctx, listDisciplinaryRecords)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListDisciplinaryRecordsRow{}
	for rows.Next() {
		var i ListDisciplinaryRecordsRow
		if err := rows.Scan(
			&i.DisciplineID,
			&i.LastName,
			&i.MiddleName,
			&i.FirstName,
			&i.Date,
			&i.Offense,
			&i.ActionTaken,
			&i.Notes,
			&i.TermName,
			&i.ReporterLastName,
			&i.ReporterFirstName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertDisciplinaryRecord = `-- name: UpsertDisciplinaryRecord :one
INSERT INTO discipline_records (student_id, term_id, date, description, action_taken, reported_by, notes)
VALUES ($1, $2, $3, $4, $5, $6, $7)
ON CONFLICT (student_id, term_id, date) DO UPDATE
  SET description  = EXCLUDED.description,
      action_taken = EXCLUDED.action_taken,
      reported_by  = EXCLUDED.reported_by,
      notes        = EXCLUDED.notes
RETURNING discipline_id, student_id, term_id, date, description, action_taken, reported_by, notes
`

type UpsertDisciplinaryRecordParams struct {
	StudentID   uuid.UUID   `json:"student_id"`
	TermID      uuid.UUID   `json:"term_id"`
	Date        pgtype.Date `json:"date"`
	Description string      `json:"description"`
	ActionTaken pgtype.Text `json:"action_taken"`
	ReportedBy  uuid.UUID   `json:"reported_by"`
	Notes       pgtype.Text `json:"notes"`
}

func (q *Queries) UpsertDisciplinaryRecord(ctx context.Context, arg UpsertDisciplinaryRecordParams) (DisciplineRecord, error) {
	row := q.db.QueryRow(ctx, upsertDisciplinaryRecord,
		arg.StudentID,
		arg.TermID,
		arg.Date,
		arg.Description,
		arg.ActionTaken,
		arg.ReportedBy,
		arg.Notes,
	)
	var i DisciplineRecord
	err := row.Scan(
		&i.DisciplineID,
		&i.StudentID,
		&i.TermID,
		&i.Date,
		&i.Description,
		&i.ActionTaken,
		&i.ReportedBy,
		&i.Notes,
	)
	return i, err
}
